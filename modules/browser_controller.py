#!/usr/bin/env python3
"""
üåê BrowserController - Î∏åÎùºÏö∞Ï†Ä Ï†úÏñ¥ Í¥ÄÎ¶¨
- ÎÑ§Ïù¥Î≤Ñ ÏßÄÎèÑ ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò
- "Íµ¨Îßå Î≥¥Í∏∞" Î≤ÑÌäº ÌÅ¥Î¶≠
- Î™©Î°ù Î™®Îìú Ï†ÑÌôò
- ÌéòÏù¥ÏßÄ Ïù∏ÌÑ∞ÎûôÏÖò
"""

import asyncio
import re
from typing import Optional, Dict, Any, Tuple
from playwright.async_api import Page


class BrowserController:
    """üåê Î∏åÎùºÏö∞Ï†Ä Ï†úÏñ¥Î•º Îã¥ÎãπÌïòÎäî ÌÅ¥ÎûòÏä§"""
    
    def __init__(self):
        # Í∏∞Î≥∏ ÎÑ§Ïù¥Î≤Ñ ÏßÄÎèÑ URL (ÌïÑÌÑ∞ Ï†ÅÏö©Îêú ÏÉÅÌÉú)
        self.base_map_url = "https://m.land.naver.com/map/37.5665:126.9780:12/SG:SMS/B2?wprcMax=2000&rprcMax=130&spcMin=66&flrMin=-1&flrMax=2"
        
        # ÏÑúÏö∏Ïãú 25Í∞ú Íµ¨Î≥Ñ Ï¢åÌëú (Ïù∏Ï†ë ÏßÄÏó≠ 10% Í≤πÏπ® ÌóàÏö© - Îß§Î¨º ÎàÑÎùΩ ÏµúÏÜåÌôî)
        self.seoul_districts_coords = {
            # Í∞ïÎÇ® 3Íµ¨ (10-15% Í≤πÏπ® ÌóàÏö©ÏúºÎ°ú Îß§Î¨º ÎàÑÎùΩ ÏµúÏÜåÌôî)
            'Í∞ïÎÇ®Íµ¨': {'lat': 37.516, 'lon': 127.055, 'btm': 37.485, 'lft': 127.030, 'top': 37.550, 'rgt': 127.085},
            'ÏÑúÏ¥àÍµ¨': {'lat': 37.485, 'lon': 127.015, 'btm': 37.455, 'lft': 126.980, 'top': 37.515, 'rgt': 127.050},
            'ÏÜ°ÌååÍµ¨': {'lat': 37.515, 'lon': 127.115, 'btm': 37.485, 'lft': 127.090, 'top': 37.545, 'rgt': 127.145},
            
            # Í∞ïÎèô ÏßÄÏó≠ (10% Í≤πÏπ® ÌóàÏö©)
            'Í∞ïÎèôÍµ¨': {'lat': 37.545, 'lon': 127.135, 'btm': 37.520, 'lft': 127.115, 'top': 37.570, 'rgt': 127.155},
            'Í¥ëÏßÑÍµ¨': {'lat': 37.555, 'lon': 127.085, 'btm': 37.535, 'lft': 127.065, 'top': 37.575, 'rgt': 127.105},
            'ÏÑ±ÎèôÍµ¨': {'lat': 37.560, 'lon': 127.045, 'btm': 37.540, 'lft': 127.025, 'top': 37.580, 'rgt': 127.065},
            
            # ÎèôÎ∂Å ÏßÄÏó≠ (10% Í≤πÏπ® ÌóàÏö©)
            'ÎèôÎåÄÎ¨∏Íµ¨': {'lat': 37.585, 'lon': 127.045, 'btm': 37.565, 'lft': 127.025, 'top': 37.605, 'rgt': 127.065},
            'Ï§ëÎûëÍµ¨': {'lat': 37.605, 'lon': 127.080, 'btm': 37.585, 'lft': 127.060, 'top': 37.625, 'rgt': 127.100},
            'ÏÑ±Î∂ÅÍµ¨': {'lat': 37.595, 'lon': 127.015, 'btm': 37.575, 'lft': 126.995, 'top': 37.615, 'rgt': 127.035},
            'Í∞ïÎ∂ÅÍµ¨': {'lat': 37.625, 'lon': 127.025, 'btm': 37.605, 'lft': 127.005, 'top': 37.645, 'rgt': 127.045},
            'ÎèÑÎ¥âÍµ¨': {'lat': 37.665, 'lon': 127.035, 'btm': 37.645, 'lft': 127.015, 'top': 37.685, 'rgt': 127.055},
            'ÎÖ∏ÏõêÍµ¨': {'lat': 37.645, 'lon': 127.075, 'btm': 37.615, 'lft': 127.055, 'top': 37.675, 'rgt': 127.095},
            
            # ÏÑúÎ∂Å ÏßÄÏó≠ (10% Í≤πÏπ® ÌóàÏö©)
            'ÏùÄÌèâÍµ¨': {'lat': 37.605, 'lon': 126.925, 'btm': 37.585, 'lft': 126.905, 'top': 37.625, 'rgt': 126.945},
            'ÏÑúÎåÄÎ¨∏Íµ¨': {'lat': 37.575, 'lon': 126.945, 'btm': 37.555, 'lft': 126.925, 'top': 37.595, 'rgt': 126.965},
            'ÎßàÌè¨Íµ¨': {'lat': 37.565, 'lon': 126.915, 'btm': 37.545, 'lft': 126.895, 'top': 37.585, 'rgt': 126.935},
            
            # Ï§ëÏã¨ ÏßÄÏó≠ (10% Í≤πÏπ® ÌóàÏö©)
            'Ï¢ÖÎ°úÍµ¨': {'lat': 37.585, 'lon': 126.985, 'btm': 37.565, 'lft': 126.965, 'top': 37.605, 'rgt': 127.005},
            'Ï§ëÍµ¨': {'lat': 37.565, 'lon': 126.985, 'btm': 37.545, 'lft': 126.965, 'top': 37.585, 'rgt': 127.005},
            'Ïö©ÏÇ∞Íµ¨': {'lat': 37.535, 'lon': 126.975, 'btm': 37.515, 'lft': 126.955, 'top': 37.555, 'rgt': 126.995},
            
            # ÏÑúÎÇ® ÏßÄÏó≠ (10% Í≤πÏπ® ÌóàÏö©)
            'Í∞ïÏÑúÍµ¨': {'lat': 37.565, 'lon': 126.825, 'btm': 37.545, 'lft': 126.805, 'top': 37.585, 'rgt': 126.845},
            'ÏñëÏ≤úÍµ¨': {'lat': 37.525, 'lon': 126.845, 'btm': 37.505, 'lft': 126.825, 'top': 37.545, 'rgt': 126.865},
            'Íµ¨Î°úÍµ¨': {'lat': 37.485, 'lon': 126.865, 'btm': 37.465, 'lft': 126.845, 'top': 37.505, 'rgt': 126.885},
            'Í∏àÏ≤úÍµ¨': {'lat': 37.465, 'lon': 126.905, 'btm': 37.445, 'lft': 126.885, 'top': 37.485, 'rgt': 126.925},
            'ÏòÅÎì±Ìè¨Íµ¨': {'lat': 37.525, 'lon': 126.915, 'btm': 37.505, 'lft': 126.895, 'top': 37.545, 'rgt': 126.935},
            
            # ÎÇ®Î∂Ä ÏßÄÏó≠ (10% Í≤πÏπ® ÌóàÏö©)
            'ÎèôÏûëÍµ¨': {'lat': 37.495, 'lon': 126.965, 'btm': 37.475, 'lft': 126.945, 'top': 37.515, 'rgt': 126.985},
            'Í¥ÄÏïÖÍµ¨': {'lat': 37.475, 'lon': 126.945, 'btm': 37.455, 'lft': 126.925, 'top': 37.495, 'rgt': 126.965}
        }
    
    async def create_mobile_context(self, playwright):
        """üì± Î™®Î∞îÏùº Î∏åÎùºÏö∞Ï†Ä Ïª®ÌÖçÏä§Ìä∏ ÏÉùÏÑ±"""
        browser = await playwright.chromium.launch(headless=False)
        context = await browser.new_context(
            viewport={'width': 390, 'height': 844},
            user_agent='Mozilla/5.0 (iPhone; CPU iPhone OS 17_1_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Mobile/15E148 Safari/604.1',
            device_scale_factor=3,
            is_mobile=True,
            has_touch=True,
            locale='ko-KR',
            timezone_id='Asia/Seoul'
        )
        page = await context.new_page()
        return browser, context, page
    
    async def navigate_to_map_and_apply_district_filter(self, page: Page, district_name: str) -> bool:
        """üó∫Ô∏è ÏßÄÎèÑÎ°ú Ïù¥ÎèôÌïòÍ≥† Íµ¨Î≥Ñ ÌïÑÌÑ∞ Ï†ÅÏö©"""
        print(f"         üåê {district_name} ÏßëÏ§ë ÌÉêÏÉâ ÏãúÏûë...")
        
        try:
            # Íµ¨Î≥Ñ ÎßûÏ∂§ URL ÏÉùÏÑ±
            district_url = self.create_district_focused_url(district_name)
            print(f"         üåê {district_name} ÎßûÏ∂§ URL Ï†ëÏÜç...")
            
            await page.goto(district_url, wait_until='domcontentloaded', timeout=30000)
            await asyncio.sleep(2)
            
            # ÌéòÏù¥ÏßÄ Î°úÎî© Ï§ëÏóê Î≤ÑÌäº Ï∞æÍ∏∞ ÏãúÎèÑ
            success = await self.search_during_page_load(page, district_name)
            
            if not success:
                # ÌéòÏù¥ÏßÄ Î°úÎî© ÏôÑÎ£å ÌõÑ Î≤ÑÌäº Ï∞æÍ∏∞
                success = await self.search_after_page_load(page, district_name)
            
            if not success:
                # Ï∂îÍ∞Ä ÌéòÏù¥ÏßÄ Ïù∏ÌÑ∞ÎûôÏÖò ÏãúÎèÑ
                success = await self.try_page_interactions(page, district_name)
            
            return success
            
        except Exception as e:
            print(f"         ‚ùå {district_name} ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Ïò§Î•ò: {e}")
            return False
    
    def create_district_focused_url(self, district_name: str) -> str:
        """üéØ Íµ¨Î≥Ñ ÏßëÏ§ë URL ÏÉùÏÑ±"""
        coords = self.seoul_districts_coords.get(district_name)
        if coords:
            return f"https://m.land.naver.com/map/{coords['lat']}:{coords['lon']}:12/SG:SMS/B2?wprcMax=2000&rprcMax=130&spcMin=66&flrMin=-1&flrMax=2"
        return self.base_map_url
    
    async def search_during_page_load(self, page: Page, district_name: str) -> bool:
        """‚è≥ ÌéòÏù¥ÏßÄ Î°úÎî© Ï§ë Î≤ÑÌäº ÌÉêÏÉâ"""
        print(f"         ‚è≥ ÌéòÏù¥ÏßÄ Î°úÎî© Ï§ë {district_name}Îßå Î≥¥Í∏∞ Î≤ÑÌäº ÌÉêÏÉâ...")
        
        max_attempts = 10
        for attempt in range(1, max_attempts + 1):
            try:
                await asyncio.sleep(0.5)
                
                if await self.check_district_button_exists(page, district_name):
                    print(f"         ‚úÖ Î°úÎî© Ï§ë {district_name}Îßå Î≥¥Í∏∞ Î≤ÑÌäº Î∞úÍ≤¨! (ÏãúÎèÑ {attempt})")
                    return await self.attempt_button_click(page, district_name)
                    
            except Exception as e:
                if attempt == max_attempts:
                    print(f"         ‚ö†Ô∏è Î°úÎî© Ï§ë ÌÉêÏÉâ Ïã§Ìå®: {e}")
        
        return False
    
    async def search_after_page_load(self, page: Page, district_name: str) -> bool:
        """‚úÖ ÌéòÏù¥ÏßÄ Î°úÎî© ÏôÑÎ£å ÌõÑ Î≤ÑÌäº ÌÉêÏÉâ"""
        print(f"         ‚úÖ Î°úÎî© ÏôÑÎ£å ÌõÑ {district_name}Îßå Î≥¥Í∏∞ Î≤ÑÌäº ÌÉêÏÉâ...")
        
        try:
            await page.wait_for_load_state('networkidle', timeout=10000)
            await asyncio.sleep(2)
            
            if await self.check_district_button_exists(page, district_name):
                print(f"         ‚úÖ Î°úÎî© ÏôÑÎ£å ÌõÑ {district_name}Îßå Î≥¥Í∏∞ Î≤ÑÌäº Î∞úÍ≤¨!")
                return await self.attempt_button_click(page, district_name)
                
        except Exception as e:
            print(f"         ‚ö†Ô∏è Î°úÎî© ÏôÑÎ£å ÌõÑ ÌÉêÏÉâ Ïã§Ìå®: {e}")
        
        return False
    
    async def try_page_interactions(self, page: Page, district_name: str) -> bool:
        """üîÑ Ï∂îÍ∞Ä ÌéòÏù¥ÏßÄ Ïù∏ÌÑ∞ÎûôÏÖò"""
        print(f"         üîÑ {district_name} Ï∂îÍ∞Ä Ïù∏ÌÑ∞ÎûôÏÖò ÏãúÎèÑ...")
        
        interactions = [
            lambda: page.evaluate("window.scrollTo(0, 100)"),
            lambda: page.evaluate("window.scrollTo(0, 0)"),
            lambda: page.tap("body") if hasattr(page, 'tap') else None,
        ]
        
        for i, interaction in enumerate(interactions, 1):
            try:
                if interaction:
                    await interaction()
                await asyncio.sleep(1)
                
                if await self.check_district_button_exists(page, district_name):
                    print(f"         ‚úÖ Ïù∏ÌÑ∞ÎûôÏÖò {i} ÌõÑ {district_name}Îßå Î≥¥Í∏∞ Î≤ÑÌäº Î∞úÍ≤¨!")
                    return await self.attempt_button_click(page, district_name)
                    
            except Exception as e:
                print(f"         ‚ö†Ô∏è Ïù∏ÌÑ∞ÎûôÏÖò {i} Ïã§Ìå®: {e}")
        
        return False
    
    async def check_district_button_exists(self, page: Page, district_name: str) -> bool:
        """üîç Íµ¨Îßå Î≥¥Í∏∞ Î≤ÑÌäº Ï°¥Ïû¨ ÌôïÏù∏"""
        selectors = [
            f"button:has-text('{district_name}Îßå Î≥¥Í∏∞')",
            f"a:has-text('{district_name}Îßå Î≥¥Í∏∞')",
            f"div:has-text('{district_name}Îßå Î≥¥Í∏∞')",
            f"span:has-text('{district_name}Îßå Î≥¥Í∏∞')",
            f"*:has-text('{district_name}Îßå')",
        ]
        
        for selector in selectors:
            try:
                element = await page.query_selector(selector)
                if element:
                    text = await element.text_content()
                    if district_name in text and 'Î≥¥Í∏∞' in text:
                        return True
            except:
                continue
        
        return False
    
    async def attempt_button_click(self, page: Page, district_name: str) -> bool:
        """üéØ Î≤ÑÌäº ÌÅ¥Î¶≠ ÏãúÎèÑ"""
        try:
            # Îçî Ï†ïÌôïÌïú ÏÑ†ÌÉùÏûêÎì§
            selectors = [
                f"button:has-text('{district_name}Îßå Î≥¥Í∏∞')",
                f"a:has-text('{district_name}Îßå Î≥¥Í∏∞')",
                f"div[role='button']:has-text('{district_name}Îßå Î≥¥Í∏∞')",
                f"*:has-text('{district_name}Îßå Î≥¥Í∏∞')"
            ]
            
            for selector in selectors:
                try:
                    element = await page.query_selector(selector)
                    if element:
                        text = await element.text_content()
                        if district_name in text and 'Î≥¥Í∏∞' in text:
                            print(f"         üéØ {district_name}Îßå Î≥¥Í∏∞ Î≤ÑÌäº ÌÅ¥Î¶≠: \"{text.strip()}\"")
                            await element.click()
                            await asyncio.sleep(2)
                            print(f"         ‚úÖ {district_name}Îßå Î≥¥Í∏∞ ÌÅ¥Î¶≠ ÏôÑÎ£å")
                            return True
                except Exception as e:
                    continue
            
            print(f"         ‚ùå {district_name}Îßå Î≥¥Í∏∞ Î≤ÑÌäº ÌÅ¥Î¶≠ Ïã§Ìå®")
            return False
            
        except Exception as e:
            print(f"         ‚ùå Î≤ÑÌäº ÌÅ¥Î¶≠ Ï§ë Ïò§Î•ò: {e}")
            return False
    
    async def switch_to_list_mode(self, page: Page) -> bool:
        """üìã Î™©Î°ù Î™®ÎìúÎ°ú Ï†ÑÌôò"""
        print(f"         üìã Î™©Î°ù Î™®Îìú Ï†ÑÌôò Ï§ë...")
        
        try:
            # Î™©Î°ù Î™®Îìú Î≤ÑÌäº Ï∞æÍ∏∞
            list_selectors = [
                "button:has-text('Î™©Î°ù')",
                "a:has-text('Î™©Î°ù')",
                "*[data-nclicks*='list']",
                "*:has-text('Î™©Î°ù')"
            ]
            
            for selector in list_selectors:
                try:
                    element = await page.query_selector(selector)
                    if element:
                        await element.click()
                        await asyncio.sleep(2)
                        print(f"         ‚úÖ Î™©Î°ù Î™®Îìú ÌôúÏÑ±Ìôî")
                        return True
                except:
                    continue
            
            # JavaScriptÎ°ú Î™©Î°ù Î™®Îìú ÌôúÏÑ±Ìôî (Îçî ÏïàÏ†ÑÌïú Î∞©Î≤ï)
            try:
                # Î™©Î°ù Î™®Îìú JavaScript Ïã§Ìñâ
                await page.evaluate("""
                    // Î™©Î°ù Î™®ÎìúÎ°ú Ï†ÑÌôòÌïòÎäî Îã§ÏñëÌïú ÏãúÎèÑ
                    if (window.location.hash !== '#mapFullList') {
                        window.location.hash = '#mapFullList';
                    }
                    
                    // Î™©Î°ù Í¥ÄÎ†® Î≤ÑÌäºÏù¥ÎÇò ÏöîÏÜå ÌÅ¥Î¶≠ ÏãúÎèÑ
                    const listButtons = document.querySelectorAll('[data-nclicks*="list"], button[class*="list"], a[class*="list"]');
                    for (let btn of listButtons) {
                        if (btn.textContent.includes('Î™©Î°ù')) {
                            btn.click();
                            break;
                        }
                    }
                """)
                await asyncio.sleep(3)
                print(f"         ‚úÖ Î™©Î°ù Î™®Îìú ÌôúÏÑ±Ìôî (JavaScript)")
                return True
            except:
                pass
            
            return True
            
        except Exception as e:
            print(f"         ‚ö†Ô∏è Î™©Î°ù Î™®Îìú Ï†ÑÌôò Ïã§Ìå®: {e}")
            return False
    
    async def extract_api_params_from_browser(self, page: Page, district_name: str) -> Optional[Dict[str, Any]]:
        """üîç Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú API ÌååÎùºÎØ∏ÌÑ∞ Ï∂îÏ∂ú"""
        try:
            current_url = page.url
            print(f"            üìç ÌòÑÏû¨ URL: {current_url}")
            
            # URLÏóêÏÑú Ï¢åÌëú Ï∂îÏ∂ú
            coord_match = re.search(r'/map/([0-9.]+):([0-9.]+):(\d+)', current_url)
            if not coord_match:
                print(f"            ‚ùå URLÏóêÏÑú Ï¢åÌëú Ï∂îÏ∂ú Ïã§Ìå®")
                return None
            
            lat, lon, zoom = coord_match.groups()
            print(f"            ‚úÖ URLÏóêÏÑú Ï¢åÌëú Ï∂îÏ∂ú: lat={lat}, lon={lon}")
            
            # ÌïÑÌÑ∞ ÌååÎùºÎØ∏ÌÑ∞ Ï∂îÏ∂ú
            api_params = {
                'lat': float(lat),
                'lon': float(lon),
                'zoom': int(zoom),
                'district_name': district_name
            }
            
            # URL ÌååÎùºÎØ∏ÌÑ∞ ÌååÏã±
            url_params = [
                ('wprcMax', 'wprcMax'),
                ('rprcMax', 'rprcMax'), 
                ('spcMin', 'spcMin'),
                ('flrMin', 'flrMin'),
                ('flrMax', 'flrMax')
            ]
            
            for url_param, api_param in url_params:
                match = re.search(f'{url_param}=([^&]+)', current_url)
                if match:
                    value = match.group(1)
                    api_params[api_param] = value
                    print(f"            ‚úÖ ÌïÑÌÑ∞ Ï†ÅÏö©: {api_param}={value}")
            
            # üéØ Îã§ÏñëÌïú Î∞©Î≤ïÏúºÎ°ú Î∏åÎùºÏö∞Ï†Ä Ï¥ù Îß§Î¨º Ïàò Ï∂îÏ∂ú
            total_count = None
            try:
                # Î∞©Î≤ï 1: "Ï¥ù 836+ Í∞úÏùò Îß§Î¨ºÏù¥ ÏûàÏäµÎãàÎã§" ÌÖçÏä§Ìä∏ Ï∞æÍ∏∞
                selectors_to_try = [
                    'text=/Ï¥ù.*Í∞úÏùò Îß§Î¨ºÏù¥ ÏûàÏäµÎãàÎã§/',
                    'text=/Ï¥ù.*Í∞úÏùò/',
                    'text=/.*Í∞úÏùò Îß§Î¨º/',
                    '[class*="count"]',
                    '[class*="total"]'
                ]
                
                for selector in selectors_to_try:
                    try:
                        elements = await page.query_selector_all(selector)
                        for element in elements:
                            text = await element.text_content()
                            if text and ('Îß§Î¨º' in text or 'Í∞ú' in text):
                                # Îã§ÏñëÌïú Ìå®ÌÑ¥ÏúºÎ°ú Ïà´Ïûê Ï∂îÏ∂ú ÏãúÎèÑ
                                patterns = [
                                    r'Ï¥ù\s*(\d+)',
                                    r'(\d+)\s*\+?\s*Í∞ú',
                                    r'(\d+)\s*Í∞úÏùò\s*Îß§Î¨º',
                                    r'(\d{2,})'  # Îëê ÏûêÎ¶¨ Ïù¥ÏÉÅ Ïà´Ïûê
                                ]
                                
                                for pattern in patterns:
                                    match = re.search(pattern, text)
                                    if match:
                                        extracted_count = int(match.group(1))
                                        # Ìï©Î¶¨Ï†ÅÏù∏ Î≤îÏúÑ Ï≤¥ÌÅ¨ (50~5000Í∞ú)
                                        if 50 <= extracted_count <= 5000:
                                            total_count = extracted_count
                                            print(f"            üéØ Î∏åÎùºÏö∞Ï†Ä Ï¥ù Îß§Î¨º Ïàò Í∞êÏßÄ: {total_count}Í∞ú (Ìå®ÌÑ¥: {pattern})")
                                            print(f"            üì± Í∞êÏßÄÎêú ÌÖçÏä§Ìä∏: '{text.strip()}'")
                                            break
                                
                                if total_count:
                                    break
                        
                        if total_count:
                            break
                            
                    except Exception as selector_error:
                        continue
                
                if total_count:
                    api_params['browser_total_count'] = total_count
                else:
                    print(f"            ‚ùå Î™®Îì† Î∞©Î≤ïÏúºÎ°ú Îß§Î¨º Ïàò Í∞êÏßÄ Ïã§Ìå®")
                    # ÌéòÏù¥ÏßÄ ÌÖçÏä§Ìä∏ ÏÉòÌîå Ï∂úÎ†• (ÎîîÎ≤ÑÍπÖÏö©)
                    try:
                        page_text = await page.text_content('body')
                        if page_text:
                            sample_text = page_text[:500]
                            print(f"            üîç ÌéòÏù¥ÏßÄ ÌÖçÏä§Ìä∏ ÏÉòÌîå: {sample_text}")
                    except:
                        pass
                        
            except Exception as e:
                print(f"            ‚ùå Îß§Î¨º Ïàò Ï∂îÏ∂ú Ïò§Î•ò: {e}")
            
            return api_params
            
        except Exception as e:
            print(f"            ‚ùå API ÌååÎùºÎØ∏ÌÑ∞ Ï∂îÏ∂ú Ïã§Ìå®: {e}")
            return None
    
    async def get_page_info(self, page: Page) -> Dict[str, Any]:
        """üìä ÌéòÏù¥ÏßÄ Ï†ïÎ≥¥ Î∞òÌôò"""
        try:
            return {
                'url': page.url,
                'title': await page.title(),
                'viewport': await page.viewport_size(),
                'user_agent': await page.evaluate('navigator.userAgent')
            }
        except Exception as e:
            return {'error': str(e)}
